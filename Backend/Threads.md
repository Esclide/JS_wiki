Многопоточность Node.js

Потоки могут помочь для CPU-нагруженных задач, а с I/O операциями встроенные средства ноды справляются лучше

Для реализации многопоточности нам может помочь Worker.

Общая структура кода получается такой:

if (isMainThread) { // isMainThread из пакета
  const worker = new Worker(__filename);
  worker
    .on('online', () => {     // поток готов начинать работу
    })
    .on('message', ({id, hash}) => {   // принимаем ID вместе с результатом
      worker.unref();       // отвязываем вспомогательный поток, позволяя основному завершиться
    })
  }
else {
  // это вспомогательный поток
  parentPort.on('message', ({id, data}) => { // parentPort из пакета, принимаем ID вместе с сообщением
    parentPort.postMessage({ // передаем ID вместе с результатом
      id
    , hash : createHash('sha256').update(data).digest('hex')
    });
  });
}

* если вам необходимо как-то увязать переданную в поток задачу и ответ на нее, то передача связующего ID туда-обратно - на вашей совести.
* все асинхронно, поэтому нет понятия порядка операций, откуда следует, что ...
* вам необходимо считать количество ответов, чтобы узнать, когда наступит момент "все готово".

* слишком много одновременно активных потоков жестко конфликтуют за ресурсы (производительность CPU, пропускная способность памяти) и сообща работают намного дольше.

Поэтому необходим алгоритм распределения задач между потоками. Самый простой - Round Robin, когда задачи выдаются по кругу. Потоки можно сделать по количеству ядер процессора

Но вот неприятность: такой алгоритм очень неравномерно нагружает потоки и не полностью утилизирует их возможности - пока кто-то простаивает, другой уже копит очередь. Обойти это можно при помощи очереди.

* при получении задачи отдаем ее первому свободному потоку или ставим в общую очередь, когда таких нет;
* при освобождении потока сразу даем ему следующую задачу из очереди.

