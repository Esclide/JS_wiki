Блокировка транзакций Postgres

https://zelark.github.io/exploring-query-locks-in-postgres/
На русском про блокировки в постгресе
Мне нравится, как написано))

параллелизм - когда что-то может выполняться независимо друг от друга параллельно (на компах можно запустить кол-во процессов, равное кол-ву процессоров). Для этого делаются ридонли реплики. Не делим один и тот же ресурс. Если один процесс нагрузил базу, то второй спокойно получает доступ к своей базе
конкурентность - несколько потребителей дерутся за один и тот же ресурс. есть конкурентность как псевдопараллелизм, когда 2 процесса используют один и тот же ресурс. но есть пропускная способность на диске. Неблокирующая конкурентность - например, чтение данных из одной базы, но из разных таблиц
ассинхронность - синхронное - любой запущенный процесс (приложение, браузер, прочее), каждый процесс поднимает свой собственный тред (стрим в терминах ОС). Один процессор - минимум 1 тред (мейн - прибитие этого треда означает прибитие процесса). Выполнили действие и ожидание ответа блокирует весь тред. асинхронное - выносим действие за пределы мейн треда (на каждое действие поднимаем тред или создаем пул тредов и кидаем действия туда). Т.е. мейн занимается только главным, а остальные действия выполняются другими тредами (пр - кассир и работники в маке - ассинхронное, кассир на заправке - синхронное)
Когда мы пишем функцию, компилятор видит ее как синхронную и синхронно кидает в стек. Если он видит асинк, то он делит эту функцию на куски и синхронно выполняет только то, что идет до await, а все остальное запихивает уже в колбэки. Т.е. async - это для компилятора, чтобы он понимал, что он вызывает ее не как обычную функцию
Аутентификгция - процесс опознания пользователя (по логику паролю, двухфакторке пытаемся убедиться, что это за пользователь)
Авторизация - есть ли у пользователя доступ на выполнение действий

У нас тут есть 2 типа блокировок
* Блокировки, которые дает база - если запрос на апдейт выполняется, то в этот же самый момент мы не можем вызвать второй запрос на апдейт, к примеру. Ну, это как я понимаю. С блокировками базы я пока не очень разобралась
* Пользовательские блокировки - т.е. которые мы можем ставить руками. И вот тут у нас уже полная свобода для творчества
Мы можем поставить в начале блокировку на всю таблицу. Можем только на запись. Они есть в нескольких вариантах - самый строгий Exclusive, который первый в приоритете и мы можем только читать данные, когда он стоит. И тип если у нас одновременно будут 2 блокировки - он и уровнем ниже, то второй будет ждать, пока не пройдет первый
Share - полегче, он тоже дает читать и блокирует операции модификации
Еще мы можем поставить блокировку через SELECT FOR UPDATE, это будет блокировка уровня строки и тогда вторая транзакция, если ей нужна будет строка FOR UPDATE из тех, которые уже были заблокированы тем, что их читают FOR UPDATE, то она будет покорно ждать, пока они освободятся

Я просто сегодня руками игралась
Добавляла в функцию PERFORM pg_sleep(sec)
И слала через консольку параллельно запросы в базу

Еще можно их объединять, чтобы прям одновременно выполнялись, через $
PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres test -c "BEGIN; SELECT lims.material_lot_register_changes('L0000008'::TEXT, 'BALTIMORE'::TEXT, NULL, false::BOOLEAN, false::BOOLEAN, 1::INT, 'ferf15'::TEXT, '{\"lotExpired\": true}'::JSONB, '2023-05-16 16:48:10.15'::TIMESTAMP); COMMIT;"&
PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres test -c "BEGIN; SELECT lims.material_lot_register_changes('L0000008'::TEXT, 'BALTIMORE'::TEXT, NULL, false::BOOLEAN, false::BOOLEAN, 1::INT, 'ferf16'::TEXT, '{\"lotExpired\": true}'::JSONB, '2023-05-16 16:48:10.16'::TIMESTAMP); COMMIT;"

Я пока сделала блокировку SHARE на уровень таблицы, ибо не поняла, какую нам строку блокировать, но Саша сказал, что всю таблицу лучше не блокировать и что лучше в начале запроса через SELECT FOR UPDATE выбирать коды контейнеров, которые заэкспайрились, и, тогда, если вызовется второй запрос и попытается эти же контейнеры поменять, то он уже будет ждать, пока пройдет первый

В статье первая часть-то, что регулируется постгресом, вторая - то, что можно навесить руками
Вторая функция, как я поняла, все равно выполнялась чуть с задержкой после первой, поэтому, когда она пришла получать строку, которой надо проставить ended_at, то там уже ничего не оказалось и она пошла дальше, так что первая поставила ended_at, а после обе транзакции добавили запись
Агась, у нас транзакция на уровне бэка ставится, так что мы объединяем эти вызовы в одну
По части с For update правильно, только, когда первая завершится, там уже будут новые записи, и вторая проставит ended_at для них и добавит свои

Задача 1.
Подняты два инстанса бэкенда и 2 инстанса функций. Оба инстанса функций одновременно отправляют запрос в бэк на проставление экспайред лотам, бэк одновременно их выполняет и мы помечаем лоты на экспайред 2 раза

Решение: Заранее вызывать записи FOR UPDATE и выходить из метода, если у нас после получения записей они не вернулись

Задача 2.
Кейс такой - приложение Яндекс Такси, необходимо обрабатывать параллельные запросы так, чтобы не вызвать такси два раза с одними и теми же параметрами (сеть затупила, человек нажал 2 раза на кнопку вызова).

Решение 1. Ввести лимиты на число активных заказов-начать транзакцию;
-UPDATE active_orders SET n=1 WHERE user_id={user_id} AND n=0;
-если update изменил 0 записей, то отдать HTTP код 409;
-вставить объект заказа в другую таблицу;
-завершить транзакцию.

https://habr.com/ru/companies/yandex/articles/442762/

Идемпотентность -  такой метод API, повторный вызов которого не меняет состояние. Здесь есть тонкий момент: результат идемпотентного вызова может меняться. Например, при повторном вызове идемпотентного API создания заказа — заказ не будет создаваться еще раз, но API может ответить как 200, так и 400. При обоих кодах ответа API будет идемпотентно с точки зрения состояния сервера (заказ один, с ним ничего не происходит), а с точки зрения клиента поведение существенно разное.  HTTP методы GET, PUT, DELETE формально считаются идемпотентными, тогда как POST и PATCH нет

Для POST запросов есть решение с использованием ключа идемпотентности. Ключ идемпотентности генерирует для запроса UUID v4 и шлет его на сервер вместе с запросом. Если такой ключ уже встречается в базе, то метод не меняет состояние и не создает новую сущность.
Проблема 1: если отправили запрос, потом поменяли параметры и повторно его отправили (в случае заказа такси), то создастся только первая сущность, а последующие запросы будут ссылаться на нее
Проблема 2: пользователь перезаходит в приложение, пока создается первый заказ, и делает заказ заново

Решение: Версионирование. Отдавать через ГЕТ не активные заказы, а версию всех заказов пользователя. При создании заказа приложение передает версию, которую оно знает (можно сделать как хэш от списка заказов или просто номером последнего изменения) и сервер при любых изменениях заказа меняет эту версию. Если версия приложения расходится с текущей, то кидаем ошибку

Чтобы избежать проблем с удалением, делаем soft delete (ended_at) и, если заказ уже был удален в течение n минут, возвращать 200, если нет, то 410


