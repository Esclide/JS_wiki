Типы индексов

PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда CREATE INDEX создаёт индексы типа B-дерево, эффективные в большинстве случаев.- Перевычисление при каждом добавлении/модификации
- Занимает сторадж

Индексы различаются различной поддержкой операторов при поиске и сравнении данных

B-Tree - натболее распространенный, поддерживает быстрый поиск и сортировку данных и может быть использован для равенства, диапазонного и частичного совпадения (используя оператор LIKE PostgreSQL). B-Tree могут быть созданы на одном или нескольких столбцах. Также оптимизатор может использовать эти индексы в запросах с операторами сравнения по шаблону LIKE и ~, если этот шаблон определяется константой и он привязан к началу строки — например, col LIKE 'foo%' или col ~ '^foo', но не col LIKE '%bar'

Hash - Используют хеш-функцию для определения местоположения записей. Они обеспечивают очень быстрый доступ к данным при точном совпадении (используя оператор «=»), но не поддерживают поиск по диапазону или частичное совпадение.
Чуть быстрее работает на операциях =, но и применяться может только на них. И не факт, что сильно быстрее. Возможно, вычисляется быстрее

GiST - Позволяют определять местоположение на основе произвольных условий и поддерживают различные типы информации. Они могут использоваться для нахождения информации на основе географических данных, полнотекстового поиска и других нестандартных запросов.
GIN, но для древоподобных структур. Обычно geometric, geografic данные (например, выпуклые полигоны и понимать, попадает ли точка в них)

GIN index - Предназначены для эффективного выполнения операций полнотекстового поиска и с использованием массивов и других сложных типов информации - поиск по json’у, массиву, всякие другие сложные структуры. Если нужно сравнение по полю, то можно просто индекс воткнуть, но если надо искать json как структуру, то это уже GIN. Он идексирует именно JSON как структуру


Классы индексов

Кластерный индекс - Определяет физический порядок хранения данных в таблице. В PostgreSQL может быть только один такой объект на каждую таблицу. При его использовании строки данных упорядочиваются на диске, что может существенно улучшить производительность операций чтения. Однако, изменение порядка данных может быть затратным и требует перестроения.

Некластерный - Также обеспечивает быстрый доступ к данным, но не определяет физический порядок хранения строк. В PostgreSQL может быть создано несколько таких объектов на одну таблицу. Они позволяют эффективно выполнять операции определения местоположения и сортировки, не требуя перестроения таблицы.

Составной индекс - Создается на нескольких столбцах таблицы. Он позволяет оптимизировать определение местоположения по комбинации значений в этих столбцах. Может быть полезен, когда в запросах используются условия фильтрации или сортировки, связанные с несколькими столбцами.


В результате кластеризации таблицы её содержимое физически переупорядочивается в зависимости от индекса. Кластеризация является одноразовой операцией: последующие изменения в таблице нарушают порядок кластеризации.
В процессе кластеризации таблицы для неё запрашивается блокировка ACCESS EXCLUSIVE. Это препятствует выполнению всех других операций (чтению и записи) с таблицей до завершения CLUSTER.

Индексы в СУБД PostgreSQL не содержат ссылку на кластерный индекс или первичный ключ, как в некоторых других (MySQL, MS SQL Server). Вместо этого, индекс в PostgreSQL содержит указатель на строку таблицы на диске (TID).
 Ещё одно отличие индексов в PostgreSQL: индекс не содержит информации об актуальной версии, поэтому нет возможности вычитать все данные и вернуть пользователю из индекса, даже если в SELECT выбираются только поля, входящие в индекс. Всё равно необходимо обращение к основной таблице, чтобы получить информацию об актуальных строках и вернуть их в результатах запроса.


Postgres Indexes

https://habr.com/ru/companies/postgrespro/articles/326096/

Индекс - специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным и обеспечения целостности, это соответствие между ключом и строками таблицы, которые идентифицируются по TID (номер блока и позиция строки)

Операции над проиндексированными данными приводят к перестроению индексов в рамках той же транзакции (при этом изменение полей, по которым не выполняется индексация, к перестроению не приводит)

Версии строк

У каждой строки есть заголовок, в котором пишется время ее создания, время завершения и статус транзакции (транзакция активна, закоммичена или отменена). Если мы обновляем строку, то, по факту, мы логически удаляем текущую версию и создаем новую

Карта видимости строк - процесс очистки отмечает страницы, которые не менялись давно, чтобы их могли видеть все транзакции

Autovacuum - настраивается, можно по проценту обновления страницы

Виды сканирования по индексам

Index Scan - сканирование по индексу. Возвращает значение TID по одному. Тут мы:
-обращаемся к тем страницам таблицы, на которые указывает TID, получаем версию строки, проверяем видимость и возвращаем данные
-хорошо работает, если данных немного. При увеличении выборки возрастают шансы, что придется возвращаться к одной и той же странице несколько раз
- на каждое значение идем в индекс. Это быстро, если мало значений и индекс в памяти. Но в какой-то момент постгрес решает, что ходить по каждому значению дорого

Bitmap Scan - хорошо работает уже на большем объеме выборки
-проходится по всей структуре и составляет карту true/false (это часть подходит под условие, это не проходит), а потом проходит и работает только с тем, что true
 - Bitmap Index Scan - возвращает все TID, соответствующие условию, по ним строится битовая карта версий строк
 - Bitmap Heap Scan - читаем версии строк из таблицы, при этом каждая таблица будет прочитана только один раз

Recheck Cond - если выборка слишком велика, то есть риск, что битовая карта версий строк не поместится целиком в оперативку. Тогда строится битовая карта страниц, содержащая хотя бы одну подходящую версию строки. Это занимает меньше места, но при чтении приходится перепроверять условия для хранящейся там строки

Если условия наложены на несколько проиндексированных полей таблицы, то можно использовать несколько индексов одновременно, при этом для каждого строятся bitmap, которые потом побитово умножаются (AND) или складываются (OR) - BitmapAnd и BitmapOr

При выборе метода сканирования планировщик смотрит специальную статистику, которая показывает, как упорядочена страница. Если значение близко к 1, значит, таблица отсортирована и можно использовать Index Scan, так как записи в таблице близко по упорядоченности к записям индекса

Seq Scan - последовательное чтение записей
Операции по индексам работают тем лучше, чем выше селективность условия. Если условию удовлетворяют много строк, то последовательное чтение бывает лучше, так как последовательно читать быстрее, чем прыгать по индексам вразнобой

Index Only Scan - если индекс уже содержит все необходимые данные. Мы все равно обращаемся к таблице, чтобы проверить видимость, но тут как раз используется карта видимости строк. Если очистка не проводилась давно, то планировщик может отказаться от такого вида поиска

Heap Fetches - число обращений к таблице. Чем оно ближе к 0, тем лучше

NULL обрабатывается отдельно, но чаще всего по нему индекс строится

Можно накладывать индексы на несколько полей или на выражение (функциональный индекс, например, lower(b))

Также можно наложить индекс только на часть строк - например, если у нас искомое значение встречается в 1% таблицы, то можно наложить индекс только на эти записи, чтобы не раздувать индекс

Построение индекса накладывает блокировку типа SHARE (можно читать, но нельзя писать). Тогда можно воспользоваться параллельным созданием индекса
create index concurrently on t(a);
Тогда блокировка меняется на SHARE UPDATE EXCLUSIVE - разрешает обновление данных, но запрещает изменение структуры таблицы. Но индекс будет строиться медленннее, а также может случиться взаимоблокировка или нарушение уникальности (нерабочие создаются, но отмечаются невалидными)

Лучше строить индекс так, чтобы новое значение было больше предыдущего (по инкременту), так как индекс будет достраиваться. Иначе индекс постоянно будет перестраиваться, если же его вставлять последним, то перестройки не будет

К индексу можно добавлять include - т.е, чтобы работал index only scan, мы можем докинуть поля, которые мы сможем брать из индекса без похода в базу. Индекс жирнее, но это быстрее

https://oxilor.ru/blog/sravnenie-indeksov-v-postgresql-dlya-poiska-po-tekstu-1

https://habr.com/ru/companies/postgrespro/articles/326096/
