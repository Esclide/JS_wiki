Postgres basic

CAP теорема

В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:

* C (consistency) — согласованность. Каждое чтение даст вам самую последнюю запись.
* A (availability) — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись).
    * P (partition tolerance) — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.

https://habr.com/ru/amp/publications/328792/

https://habr.com/ru/articles/258145/

https://habr.com/ru/amp/publications/769102/

Распределенные транзакции

Проблема - необходимо обновление БД в двух сервисах в рамках одной транзакции (пр: обновил один сервис - уведомил второй - второй тоже обновил).

Решение:

1. Модульный монолитКогда строгая связь важнее масштабируемости. Каждый из микросервисов - отдельная библиотека, находящиеся в одном пространстве и использующие одну БД. Их в рамках монолита можно разделить

￼

	Сервисы будут объединены сервисом-оберткой, которая уже будет отвечать за транзакцию	Минусы - единый рантайм (нельзя независимо деплоить)

2. Двухфазный коммитНеобходим экземпляр менеджера транзакций. Код приложения обращается к координатору, получает номер транзакции, обращается с ним к остальным системам и просит их начать транзакцию с таким номером. Когда запросы прошли, приложение опять идет к координатору с просьбой сделать коммит, тот отправляет всем сервисам сигнал Prepare, данные блокируются и, если у всех запросы прошли успешно, то посылается сигнал commitЭтот протокол обеспечивает атомарность и гарантирует изоляцию при записи и чтенииОднако это снижает производительность системы и завязывает работу приложения на работу менеджера транзакций. Также не все системы это поддерживают (пр: NoSql)
3. Оркестрация (оркестратор - камунда, Durable Functions, пр) - если хотим ослабить требования к консистентности, сохранив управление из одного местаЕсть один сервис - оркестратор, который запускает транзакции в остальных сервисах и вызывает компенсирующие транзакции, если что-то пошло не так (ретраи и роллбеки)Методы сервисов должны быть идемпотентными (не менять состояние в случае ретраев), а также должны быть эндпоинты для отката транзакцийНо тут есть минус - возможны невосстанавливаемые падения в случае выполнения компенасаторных операций
4. SAGA Хореография - альтернатива Оркестрации, но без оркестратораКаждый сервис выполняет локальную транзакцию и публикует события, вызывающие транзакции в других сервисах. С двойной записью - коммитим транзакцию и отправляем сообщение (или наоборот) - но тут проблема в доступностиБез двойной записи - когда первый сервис просто записывает данные, а второй периодически ходит и смотрит, не поменялось ли чего. Но тут минус в необходимости постоянного перезапроса данных. Но можно использовать сервис для захвата изменений в БД, записывать их в кафку, а второй сервис уже будет слушать топик кафкиМинус - нет изоляции чтения и сложнее отлаживать, зато быстро и никакие объекты не блокируютсяВыбирать подход необходимо от требований к данным. Чем выше масштабируемость, тем ниже консистентность данных
Уровни изоляции

Это значение, определяющее, к каким данным у нас будет доступ в случае параллельно запущенных транзакцийПостгрес реализует только три уровня

Read committed (default)
видит только те данные, которые были зафиксированы до начала запроса; он никогда не увидит незафиксированных данных или изменений, внесённых в процессе выполнения запроса параллельными транзакциями. По сути запрос SELECT видит снимок базы данных в момент начала выполнения запроса. Однако SELECT видит результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы

UPDATE, DELETE, SELECT FOR UPDATE и SELECT FOR SHARE при поиске ведут себя так же, как SELECT, но если эти строки правятся другой транзакцией, то выполнение будет отложено до ее завершения. Если транзакция откатилась - просто продолжаем дальше, если завершилась успешно - заново прогоняем WHERE (но толкьо для уже полученных данных) и продолжаем работать уже с новыми данными, если они все еще подходят
Есть случаи, когда такой уровень не подходит

BEGIN;
UPDATE website SET hits = hits + 1;
-- выполняется параллельно:  DELETE FROM website WHERE hits = 10;
COMMIT;

Тут DELETE не удалит ничего, так как на момент начала он выберет строку с 10, которая после завершения транзакции будет 11
Снимок состояния делается на момент начала каждого запроса (последовательные селекты могут видеть разные данные)
Repeatable Read

Еще строже. Отличается от предыдущего тем, что снимок состояния делается в момент первого запроса, так что последовательные селекты видят одинаковые данныеНе может изменять или блокировать строки, изменённые другими транзакциями с момента её начала, так что если мы пытаемся поменять строку, заблокированную другой транзакцией, то упадем с ошибкой

Нужно быть готовым повторить транзакцию

Serializable

Самая строгая изоляция. Работает как предыдущий, но отслеживает условия, при которых результат параллельно выполняемых транзакций может не совпадать с результатом этих же транзакций, выполняемых по очереди. Если такое замечено - падает с ошибкой

Подключение к Postgres через NodeJS

Используется библиотека pg

1. Создаем Pool, где указываем данные для поключения к базе
2. Создаем клиента через pool.connect()
3. Добавляем 2 реализации запросов - с транзакией, когда мы возвращаем клиента и в дальнейшем выполняем запросы через него, или же без транзакии, когда мы на каждый запрос создаем клиента

Data Access Abstraction Layers

В качестве слоев абстракции может выступать ORM - решениe для сопоставления объектов в программе с таблицами базы данных. Он позволяет разработчикам взаимодействовать с объектами вместо того, чтобы писать запросы к базе данных. ORM позволяет строить динамические запросы с помощью Query Builder и абстрагироваться от особенностей конкретной базы данных

Спустя время обнаруживается, что:
* Множество возможностей определенной БД не поддерживается ORM (напр, JOIN LATERAL в TypeORM). ORM поддерживает множество баз данных, и ее возможности обычно ограничиваются теми, что существуют в каждой из них.
* Если вы не сможете создать определенную колонку в таблице, используя ORM, то вам придется сделать это с помощью миграции. В это же время вы должны отключить синхронизацию таблицы, чтобы поле, созданное в результате миграции, не было удалено. Отныне любые изменения в эту таблицу должны будут вноситься с помощью миграций (даже в среде development).
* SQL-запросы не всегда генерируются так, как вы ожидали, и они начинают выполняться медленно по мере роста данных в базе. Существует также риск того, что один и тот же запрос, написанный с использованием ORM, сегодня будет одним, а завтра другим (после обновления).
* Некоторые свойства сущностей, по умолчанию, могут использовать некорректный тип в базе (напр, TypeORM хранит Date как timestamp, а не timestamptz). В результате вы перепроверяете, как фактически хранится каждый тип в базе данных или всегда указываете его явно.
Когда вы пишете SQL-запросы вручную, таких проблем не возникает, и запросы всегда выполняются точно так, как они написаны.

Создание индекса - тоже весело. Чтобы его создать, надо:

1. Проверить, поддерживается ли данный тип индекса в ORM. Если да, то создать его используя ORM.
2. Если индекс не поддерживается, то добавить новую миграцию с SQL-запросом, который создает индекс.
3. Добавить команду, которая скажет ORM, чтобы данный индекс игнорировался при синхронизации. Иначе индекс будет удален.

Когда запросы становятся сложнее, надо контролировать, как ORM их составляет

https://oxilor.ru/blog/ya-nikogda-bolshe-ne-budu-ispolzovat-orm

Подходы к хранению и поиску данных

- LSM дерево - журнал (данные, где запись ведется в конец) хранится на диске, в памяти хранится хэш-таблица "индекс-значение". Но при сбое записанные позже всего данные могут потеряться. Каждый ключ может встречаться несколько раз до уплотнения. Зато запись быстрее. Но чтение межденнее
- B tree - данные пишутся на диск страницами фиксированного размера (около 4Кб) с парами ключ-значение с сортировкой по ключу. Каждый узел - массив со ссылками на диапазон страниц (хранятся в памяти). Логируют то, что планируется добавить, что повышает устойчивость к сбоям. Они хороши для обеспечения транзакций - каждый ключ встречается в индексе только в одном месте


database administration tools.
database
performance analysis and optimizations.

query optimization
aggregation,
relational algebra
formulas application,
data structure
exposal, database functions, etc.).
Basic knowledge of
replication and sharding - репликация - полное копирование БД на другой сервер, шардирование - разбиение данных по разным нодам
Basic knowledge of
Entity Relationship
Diagram notations
Basic knowledge of
search solutions
(ElasticSearch,
Algolia, etc.)

https://habr.com/ru/amp/publications/535616/
