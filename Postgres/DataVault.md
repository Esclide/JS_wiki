Data Vault и аналоги

Это концепция, есть разные интерпретации

Цель - хранение исторических правок (истории)
Можно было избавиться от линков

+ ты делаешь в пределах одной БД
+ синхронно - напрямую обращаемся к базе
+ все делается в рамках одной транзакции

у нас ended_at используется неоднозначно - и для обновления состояния, и для удаления, непонятно, зачем именно проставляем

Другие варианты:

отгружать исторические данные в отдельную базу данных, а в основной хранить только текущее состояние. При смене данных предыдущее состояние уводится в отдельную БД, а новое добавляется в текущее
При этом записи надо перекладывать синхронно (чтобы не сбить порядок)
- Нет возможности сделать все в рамках одной транзакции (что делать, если одна база отвалилась)


Почитать: CQRS (command query request segregation)
Концепция, разделяем команды (создание/обновление, не возвращает сущности) и запросы (чисто на получение)
Ассинхронная обработка команд - мы ее кидаем в очередь и продолжаем работу
Журналируемая очередь (журнал править нельзя)
Лог действий накапливается. Команда кладет запись в лог, а потом машинерия это действие обрабатывает
Работает по ивент сорсингу
Пример: команда "создай контейнер с типом х …."
кладем команду в очередь, она все выполняет и создает сущности. При обновлении по месту обновляется
Сейчас концепция мигрировала в кафку
+разделение зон ответственности
+можно более атомарно масштабироваться
-дольше ждет (потому что большее количество виртуальных рук)

