Call Stack

ip (instruction pointer) - указатель на ячейку в оперативной памяти, содержащую выполняемый в данный момент код. Каждая команда ассемблера - отдельная ячейка

cs: ip => 0x0006  это MOV ax, 123

call - вызов адреса памяти, по которому этот вызов должен произойти. По этому адресу находится кусочек кода, который мы хотим переиспользовать (набор команд)

Т.е. мы доходим до этого метода call, перемещаемся на ячейку памяти, которую нам надо вызвать, и чтобы вернуться к тому же месту, у нас есть регистровая пара ss:sp (stask pointer).

На уровне самого процессора реализована структура, называемая стеком. Когда процессор начинает выполнять CALL, то он внутрь стека кладет адрес следующей за CALL команды. Т.е. внутри оперативной памяти появится число, указывающее на команду, которая должна будет выполниться следующей.

В команде CALL реализована команда RET, которая извлекает верхнее значение из стека и помещает ее в регистр ip.

PUSH - добавляет в стек новое значение памяти, куда мы перейдем после выполнения команды RET

Call Stack - каждое выполнение команды CALL помещает в Stack адрес следующей за CALL команды.

￼

Если проецировать это на JS, для его выполнения он должен войти в Execution Context. Одновременно с этим существует Execution Context Stack - на тот момент времени, когда мы вызываем функцию, то внутри стека появляется другая структура (Execution context), которая сопровождает выполнение кода внутри вызываемой функции. Если внутри вызывается еще функция, то в стек добавляется еще один Execution context, и в тот момент, когда мы из функции вышли, ее контекст удаляется из стека и выполнение переходит в следующему

Этот процесс полностью похож на процесс Call Stack’а. Внутри спецификации JS этого термина нет, но выполнение аналогично
