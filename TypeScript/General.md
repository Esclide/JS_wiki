Typescript

https://scriptdev.ru/guide/018/#enum

Enum

Enum — это конструкция, состоящая из набора именованных констант, именуемая списком перечисления и определяемая такими примитивными типами, как number и string

let value: number = Fruits.Apple; // 0
let identificator: string = Fruits[value]; // “Apple”

Но в случае, когда константам присваиваются строки, ассоциируется только ключ со значением. Обратная ассоциация (значение-ключ) — отсутствует.

Литеральный тип

Если перечисление составляют только строковые константы, то в качестве значения могут быть присвоены только они
Если в перечислении присутствует константа с числовым значением, в качестве значения может быть присвоено любое число.

Tuple (Кортеж)

Кортеж задает уникальный тип для каждого элемента массива.

Помимо этого семантику типов кортежей можно повышать за счет добавления им меток.

// пример кортежа с помеченными элементами
const f = (p: [a: string, b: number]) => {};

This

в TypeScript ссылка this вне конкретного объекта ссылается на тип any, что лишает ide автодополнения. Для таких и не только случаев была реализована возможность декларировать тип this непосредственно в функциях.
this указывается в качестве первого параметра любой функции, и как обычный параметр имеет аннотацию типа, устанавливающую принадлежность к конкретному типу.

interface IT1 {
  p1: string;
}

function f1(this: IT1): void {}

Несмотря на то, что this декларируется в параметрах функции, таковыми оно не считается. Поведение функции с декларацией this аналогично поведению функции без декларации this. Единственное, на что стоит обратить внимание, что в случае указания принадлежности к типу, отличному от void, не получится вызвать функцию вне указанного контекста.

Интерфейс

Класс, реализующий интерфейс, обязан реализовать все описанные в нём члены. Поэтому интерфейс является гарантией наличия описанных в нем характеристик у реализующего его объекта. Все члены, описанные в интерфейсе, неявно имеют модификатор доступа public. Интерфейс предназначен для описания api или другими словами состояния и поведения, предназначенного для взаимодействия внешнего мира с объектом.

в интерфейсе нельзя декларировать свойства get и set, они декларируются автоматом

реализовывать (implements) и расширять (extends) инлайн интерфейс нельзя

В случае, если в одной области видимости объявлено несколько одноимённых интерфейсов, то они будут объединены в один.

Если в нескольких одноимённых интерфейсах будут описаны одноимённые методы с разными сигнатурами, то они будут расценены, как описание перегрузки. К тому же, интерфейсы, которые описывают множество одноимённых методов, сохраняют свой внутренний порядок.
сигнатуры, содержащие в своем описании литеральные строковые типы, всегда размещаются перед сигнатурами, у которых нет в описании литеральных строковых типов.

Принцип разделения интерфейса

В классе метод, которому не нужны какие-то переменные для выполнения, не должны иметь к ним доступ. Для этого необходимо дробить интерфейс на небольшие составляющие (общий интерфейс extends мелкие, класс implements этот общий интерфейс и каждый метод принимает переменную конкретного мелкого интерфейса)

Интерфейс также может extends класс, чтобы описать его структуру
Интерфейс, полученный путем расширения типа класса, может быть реализован только самим этим классом или его потомками, поскольку помимо публичных (public) также наследует закрытые (private) и защищенные (protected) члены.

Объектные типы с индексными членами

Использовать можно также для классов, ограничивая то, какие поля мы там можем объявить
Нельзя при этом использовать модификаторы доступа и static

тело объекта или класса, имеющего определение индексной сигнатуры, не может иметь определения членов других типов.

С ключевым словом readonly нельзя перезаписать поля в объекте (или добавлять после создания объекта), но можно объявлять другие переменные и перезаписывать их

￼

К тому же, объекты и классы, имеющие определение индексной сигнатуры, не могут содержать определения методов.

Классы

Если сделать конструктор приватным, то экземпляр класса нельзя будет создать или класс расширить
Протектед - можно расширить

Полю, к которому применен модификатор readonly, не обязательно присваивать значение в момент объявления. Но в таком случае присвоить ему значение можно будет только из конструктора класса, в котором это поле объявлено.

если интерфейс объявлен в одной области видимости с одноимённым классом, то компилятор считает, что класс реализовал этот интерфейс.


