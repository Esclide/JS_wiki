TS Config

tsconfig.json поддерживает наследование. Опции можно разделить по некоторому принципу, описать их в разных файлах и объединить с помощью специальной директивы

tsconfig.json состоит из двух частей. Какие-то опции необходимо указывать в root, а какие-то в compilerOptions

root:
	extends - Указывает путь к файлу из которого нужно унаследовать опции
	files - Указать список конкретных файлов для компиляции. Если оставить пустой, то будет использоваться include
	include - по умолчанию ["**/*"] - поиск во всех папках
	exclude - исключать файлы, которые включились через include
	references - пути до других используемых проектов
	typeAcquisition - используется только для проектов на js, получение типов

compilerOptions

	target - версия ECMAScript, в которую будет скомпилирован код
	module - модульная система (ES6/ CommonJS)
	moduleResolution - стратегия импорта модулей (node/classic) - используется node
	lib - если используем старую версию target с полифилами, указываем для понимания, какие возможности языка у нас присутствуют
	outDir - папка, куда будет помещаться транспилированный код и артефакты
	outFile - собирает весь код в один файл, но не работает с нормальными модулями
	allowSyntheticDefaultImports - Если какая-либо библиотека не имеет default import, лоадеры вроде ts-loader или babel-loader автоматически создают их. Однако, d.ts-файлы библиотеки об этом не знают, так что этим мы это правим
	esModuleInterop - позволяет импортировать CommonJS пакеты как ES6. Активирует и предыдущую опцию, что позволяет упорядочить импорты
	alwaysStrict - Компилятор будет парсить код в strict mode и добавлять “use strict” в выходные файлы
	downlevelIteration - позволяет правильнее генерировать for/of , spread циклы в for/of для неподдерживающих версий, но при этом теряем в производительности
	forceConsistentCasingInFileNames - чувствуительность к регистру для импорта файлов
	allowJs - обработка в том числе и js файлов (если проект не полностью портирован на ts)
	checkJs - проверка ошибок в js файлах
	experimentalDecorators и emitDecoratorMetadata - включение синтаксиса и предоставление декораторам метаданных

Флаги строгости

Strict Checks

На самом деле, TypeScript из коробки мало чем отличается от JavaScript. Поэтому если изначально не подтюнить конфиг проекта, то большая часть преимуществ языка не будет задействована

по умолчанию эти флаги стоят в false

alwaysStrict - включает добавление строки "use strict" в каждый скомпилированный файл

strict - его включение автоматически активирует абсолютно все флаги секции Strict Checks, включая и alwaysStrict

noImplicitAny - Для компилятора тип any означает «это может быть что угодно, передаю управление и ответственность разработчику». Флаг говорит, что в подобных ситуация разработчик должен явно писать any

strictNullChecks - По принципу наследования вместо переменной любого типа: string, boolean, number и т. д – можно передать значение undefined или null. С данным флагом компилятор больше не позволяет передавать undefined или null туда, где ожидаются переменные других типов, если это не разрешено явно.

strictPropertyInitialization - следит, чтобы объявленные свойства класса всегда были инициализированы

strictFunctionTypes - включает более строгую проверку сигнатур функций.

noImplicitThis - При использовании this проверяет, что контекст выполнения известен. Можно передавать контекст в функцию первым аргументом, тогда он не будет считаться за аргумент, но будет типизирован

strictBindCallApply - включает более строгую проверку сигнатур при использовании соответствующих методов: bind, call, apply (что переданные параметры совпадают по типу с функцией, которая их принимает)

Linter Checks

флаги этой группы проверяют не соответствие типов, а качество кода. Некоторые можно заменить линтером. Все флаги по умолчанию false

noPropertyAccessFromIndexSignature - запрещает обращаться к свойствам объекта через точку, если свойства объекта описаны не явно, а через произвольные параметры

noUncheckedIndexedAccess - добавляем неявно указанным полям undefinedconst strings: string[] = ['hello'] - тут любое поле будет string | undefined. Другими словами, при данной конфигурации в обмен на безопасность в некоторых случаях придётся платить проверками, которые не несут смысла только для того, чтобы укротить строптивый компилятор. Выглядит это крайне костыльно.

noImplicitReturns - Флаг проверяет, чтобы все ветки функции возвращали значение

noFallthroughCasesInSwitch - Флаг проверяет наличие break в операторе switch/case

noUnusedLocals - Код проверяется на наличие неиспользуемых переменных

noUnusedParameters - Код проверяется на наличие неиспользуемых аргументов функций и методов




