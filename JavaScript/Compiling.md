Компиляция и интерпретация

https://habr.com/ru/companies/ruvds/articles/337460/

Компилируемый - программа целиком компилируется в бинарный файл и поставляется уже в нем

Интерпретируемый - программа поставляется в исходном коде и потом происходит построчное преобразование в бинарный код и исполнение

JS поставляется в исходном коде, т.е. он интерпретируемый, но как бы не совсем, так как там все равно происходит предварительная компиляция кода перед его выполнением, но минуется создание бинарного файла. В этом помогает JIT

Для исполнения JS есть множество движков. V8 самый популярный, используется в Node и в Chrome Based браузерах. Отдельный движок есть для IE, для Edge, для FireFox и т.д.

Исполнение JS кода пооисходит по следующим этапам:
- Парсинг - превращаем код в абстрактное синтаксическое дерево (AST)
- Интерпретатор - превращает дерево в байткод для дальнейшей компиляции. Есть небольшая оптимизация (пр. выкидываем неиспользуемые куски кода)
- Оптимизирующая JIT компиляция (пришла на место интерпретации). Работает во время исполнения приложения.
- Исполнение

JIT компиляция

Пытается угадать, как код будет исполняться, чтобы его оптимизировать на основании предыдущего кода
Т.е. если у нас в метод несколько раз передавался number, он оптимизирует его под number. Если же мы потом передадим что-то другое, то произойдет деоптимизация

Есть горячие и холодные функции. Холодные - вызывались мало раз, горячие - много раз и мы пытаемся их оптимизировать

Для оптимизации объектов используются Hidden Classes (В V8 - Map). Они описывают структуру объектов
Благодаря этому оптимизируется обращение к полям объекта - нам не надо лазать в прототипы, по map мы видим, где у нас это поле.
￼
Сначала оптимизировали под объект с одним параметром, потом с двумя, потом сдались и не оптимизируем. Переход между мономорфным и полиморфным состояниями дорогой, потому что нужно будет сходить в интерпретатор, получить код заново и заново его оптимизировать. Количество полиморфных состояний меняется в зависимости от развития движка, но они ограничены

Типы массивов

В V8 6 специальных типов массивов

1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS — просто упакованный массив small integer. Для него есть оптимизации.

  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS — упакованный массив double элементов, для него тоже есть оптимизации, но более медленные.

  3. [1, 2, 3, 4, ’X’] // PACKED_ELEMENTS — упакованный массив, в котором есть объекты, строки и все остальное. Для него тоже есть оптимизации.

Следующие три типа — это массивы того же типа, что первые три, но с дырками:

  4. [1, /*hole*/, 2, /*hole*/, 3, 4] // HOLEY_SMI_ELEMENTS

  5. [1.2, /*hole*/, 2, /*hole*/, 3, 4] // HOLEY_DOUBLE_ELEMENTS

  6. [1, /*hole*/, ’X’] // HOLEY_ELEMENTS

Когда в ваших массивах появляются дырки, оптимизации становятся менее эффективными. Они начинают работать плохо, потому что невозможно подряд пройти по этому массиву, перебирая его итерациями. Каждый последующий тип хуже оптимизируется
Мы можем при оптимизации идти только вниз по этой схеме, но не наверх. Т.е. ухудшать оптимизацию мы можем, а улучшать - нет

Сборщик мусора

> Создали объект - он в пространстве молодых объектов
> Запустилась очистка. Нельзя достичь объекта от корневого - очищаем. Можно - переносим в старые объекты

Scavenge - очистка молодых объектов (быстрый, но не эффективный)
Mark-Sweep - очистка старых объектов (медленный, но эффективный)


1. Порядок свойств объектов. Всегда инициализируйте свойства объектов в одном и том же порядке. Нужно это для того, чтобы одинаковые объекты использовали одни и те же скрытые классы, и, как следствие, оптимизированный код.
2. Динамические свойства. Добавление свойств к объектам после создания экземпляра объекта приведёт к изменению скрытого класса и к замедлению методов, которые были оптимизированы для скрытого класса, используемого объектами ранее. Вместо добавления свойств динамически, назначайте их в конструкторе объекта.
3. Методы. Код, который несколько раз вызывает один и тот же метод, будет выполняться быстрее, чем код, который вызывает несколько разных методов по одному разу (из-за встроенных кэшей).
4. Массивы. Избегайте разреженных массивов, ключи которых не являются последовательными числами. Разреженный массив, то есть массив, некоторые из элементов которого отсутствуют, будет обрабатываться системой как хэш-таблица. Для доступа к элементам такого массива требуется больше вычислительных ресурсов. Кроме того, постарайтесь избежать заблаговременного выделения памяти под большие массивы. Лучше, если их размер будет увеличиваться по мере надобности. И, наконец, не удаляйте элементы в массивах. Из-за этого они превращаются в разреженные массивы.
5. Числа. V8 представляет числа и указатели на объекты, используя 32 бита. Он задействует один бит для того, чтобы определить, является ли некое 32-битное значение указателем на объект (флаг — 1), или целым числом (флаг — 0), которое называется маленьким целым числом (SMall Integer, SMI) из-за того, что его длина составляет 31 бит. Если для хранения числового значения требуется более 31 бита, V8 упакует число, превратив его в число двойной точности и создаст новый объект для того, чтобы поместить в него это число. Постарайтесь использовать 31-битные числа со знаком везде, где это возможно, для того, чтобы избежать ресурсоёмких операций упаковки чисел в JS-объекты.

Если не может аллоцировать память, то v8 идет
1. Просить память у оперативки
2. Если не сработало, то проходит по существующим объектам и пытается найти что-то на удаление. Это долго и выполняется только если система отказала
