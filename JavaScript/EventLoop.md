Event loop

Технически, тот факт, что Node.js использует один поток не на 100% верно. Node.js на самом деле использует много потоков, но цикл событий и пользовательский код выполняются в одном потоке. Node.js использует управляемым событиями неблокирующую модель ввода-вывода, которая делает его легким и эффективным.

Микротаски - отложенные задачи с бОльшим приоритетом:

- операции с промисами
- операции с очередью мутации (например, используемые в API MutationObserver для наблюдения за изменениями DOM);
- операции, связанные с queueMicrotask(), — функцией для явного добавления микрозадач

Макротаски

- обработка таймеров
- обработка событий пользовательского ввода (например, клики, скроллинг);
- выполнение AJAX-запросов.

EventLoop - пример неблокирующего ввода/вывода. К неблокирующему вводу/выводу (вообще в принципе к операциям ввода/вывода) мы относим сетевые запросы и работу с файлами.
На примере с файлом - делается запрос в демультиплексор событий, сюда отправляется ресурс (ссылка на файл), нужная операция и callback. Демультиплексор событий регистрирует этот запрос и возвращает управление непосредственно приложению — таким образом, оно не блокируется. Затем он выполняет операции над файлом, и после этого, когда файл будет прочитан, callback регистрируется в очереди на выполнение. Затем Event Loop постепенно синхронно обрабатывает каждый callback из этой очереди. И, соответственно, возвращает результат приложению. Дальше (если необходимо) всё делается снова.
Проблема была в том, что в каждой операционной системе демультиплексор реализован по-разному, так что была написана обертка libuv. Это библиотека, написанная на C - единый интерфейс работы с этими демультиплексорами событий.


В Linux, в принципе, на текущий момент все операции с локальными файлами — блокирующие. Т. е. вроде бы как есть неблокирующий ввод/вывод, но именно при работе с локальными файлами операция всё равно блокирующая. Именно поэтому для эмуляции неблокирующего ввода/вывода libuv использует внутри потоки. Из коробки поднимается 4 потока, и здесь нужно сделать самый важный вывод: если мы выполняем какие-то 4 тяжёлые операции над локальными файлами, соответственно, мы заблокируем всё наше приложение (именно в ОС Linux, в других ОС такого нет).


Фазы Event Loop в Node js

Event Loop — это цикл событий, и он бесконечен до тех пор, пока есть что выполнять

Сначала выполняются nextTickQueue, потом microtask queue, потом уже все остальные

￼

1. Таймеры - у нас есть куча таймеров, берётся таймер с самым маленьким временем, сравнивается с текущим времени Event Loop'а, и, если настало время для исполнения данного таймера, выполняется его callbackЕсли у данного таймера стоит флаг repeat, то он снова помещается в очередь событий и потом точно так же обрабатывается (как у setInterval)
2. I/O callback’и - выполняются колбэки для неблокирующего ввода/вывода, т. е. это именно те функции, которые используются после запроса в базу данных или другой ресурс или на чтение/запись файла. Они выполняются именно на данной фазе
3. Ожидание, подготовка - внутренние операции колбэков, на эту фазу мы повлиять не можем
4. Опрос - Здесь выполняется весь наш код, который мы пишем на JS. Первоначально все запросы, которые мы делаем, попадают именно сюда, и именно здесь Node.js может быть заблокирована. Если сюда попадёт какая-либо тяжёлая операция по вычислению, то на этом этапе наше приложение может просто зависнуть и ожидать, пока не выполнится данная операция.
5. Проверка - В Node.js есть таймер setImmediate, его callback'и выполняются на этой фазе.
6. Collback’и событий close - Например, web-сокету нужно закрыть соединение, на этой фазе будет вызван callback этого события.
Выражение await не блокирует поток, в котором оно выполняется. Вместо этого оно указывает компилятору объявить оставшуюся часть асинхронного метода как продолжение ожидаемой задачи. Управление затем возвращается методу, вызвавшему асинхронный метод. Когда задача завершается, она вызывает свое продолжение и возобновляет выполнение асинхронного метода с того места, где она была прервана.
Отличия браузера от Node.js
* В браузере есть
    * очередь микротасков от Promise, mutation observer
    * очередь событий от интерфейса и таймеров
    * raf callbacks
    * render страницы каждые 1/60 сек
* В Node.js
    * event loop из libuv
    * стадии event loop в libuv
    * process.nextTick и Promise
    * setImmediate, setTimeout

метод ReadFile выполняется асинхронно. Как только встречается эта строка, управление передается в Libuv, где происходит чтение файла. Это не делается в основном потоке. Вместо этого используются рабочие потоки (worker threads) из пула потоков (Thread Pool) Libuv (по умолчанию 4 потока). Как только чтение завершено, соответствующий обратный вызов помещается в очередь (Event Queue), которая используется циклом событий (Event Loop). На следующей итерации цикла событий, во время фазы выполнения обратного вызова (callback), этот обратный вызов (callback) будет помещен в стек вызовов (Call Stack) V8 и в конечном итоге будет выполнен. Вся эта работа выполняется в фоновом режиме, и основной поток Node.js отвечает только за выполнение обратных вызовов. Это то, что подразумевается под “неблокирующим вводом-выводом”, и именно поэтому в каждом руководстве по Node.js, которое вы могли встречать во время изучения, предлагают использовать асинхронные методы вместо синхронных.

Подробнее

Стандарт eventLoop везде разный - в браузере одна спецификация, в ноде другая
Описание Event Loop соответствует спецификации JS об очереди выполнения задач. В JS есть 3 очереди выполнения задач:
1. Generic job - список, где присутствуют задачи, порядок выполнения которых не гарантирован
2. Promise queue - очередь
3. Timeout queue - очередь, связанная с таймаутами, когда несколько потоков пытаются получить доступ к одной и той же области памяти
В ноде и браузере создали 2 очереди, которые и используются в eventLoop1.  Microtask queue - попадают все события, вызванные реакцией на промисы. Выполняются по порядку, пока все не будет выполнено
2. Task queue - не очередь, а список. Не гарантирует порядка выполнения задач. Называют macrotask queue, но в спецификации этого нет. Все события, вызванные внешним АПИ (пр. клик, setTimeout)

Чтобы хост среда (браузер) дала понять рантайму, что нужно что-то выполнить, существует generic job или task queue или макротаски (но в спецификации этого термина не существует)
Когда выполняется событие, среда берет событие из task queue (область хост среды), помещает в generic job (рантайм) и только тогда рантайм начнет это выполнять
Также в рамках спецификации

Принцип eventLoop

Когда в task Queue появляются таски, из этого списка хост среда выполняет один из них и, закончив выполнение колбэка, проверяется связанная с ней microtask queue и, если там что-то есть, то все будет выполнено в той очередности, в которой там присутствует
Когда микротаски закончились, возвращаемся в task queue

Пример

Воткнули setTimeout - колбэк попадает в task queue в тот момент, когда хост среда посчитала, что пришло время (таймер истек)
then у promise попадает в microtask queue
Код, который выполняется - это уже задача из task queue. По завершению мы проверяем microtask queue

Task queue и порядок выполнения

Задачи из Task queue также должны выполняться одна за одной, хоть это и является сетом. Но в Task queue могут находиться данные для нескольких агентов одной хост среды. Сейчас браузеры под каждую вкладку создают нового агента в хост среде, но так было не всегда и это можно поменять в конфигурации

В спецификации html выполняются из Task queue только те задачи, которые относятся к текущей вкладке

Многопоточность

Многопоточность не имеет ничего общего с ассинхронностью и ивент лупом. Они могут быть связаны, если реакция на событие обрабатывается в отдельном потоке, но на фронте, например, веб врокер не имеет доступа к DOM, так как не поддерживается работа с DOM в несколько потоков

JS синхронный или асинхронный

Зависит от цели вопроса. Если имеется в виду “могу ли я на чистом js, вне его среды выполнения, написать код, который будет выполняться параллельно друг другу, если то позволяет архитектура системы, в которой он выполняется”, то и да, и нет. Спецификация это разрешает, но при этом потоки в ней виртуальные. JS - это абстракция, он ничего не знает о среде, в которой он будет выполняться. Он предоставляет возможность для этого, а то, будет ли он выполняться ассинхронно - это уже вопрос среды, в которой он был вызван.
В спецификации описаны случаи параллельного доступа к одной области памяти и что с этим делать. Структура js: хост среда, внутри которой вмонтирован рантайм. Она знает о блоках кода языка js, для выполнения каждого из которых создается агент, в рамках которого код выполняется последовательно. Но хост среда может создать десятки агентов и блоки из них выполняются параллельно
Сейчас все задачи из вкладок выполняются параллельно, так как они запущены в разных агентов

Так что тут вопрос некорректный. JS не может ответить на него, так как его уровень абстракции лежит за пределами этого. Но в спецификации позволяется в хост среде распараллелить выполнение кода и запускать его асинхронно

Job и realm

job - минимальный объем кода, выполняемый рантаймом (пр. функция)
realm - внутренняя структура, содержащая все необходимое для выполнения job (ссылки на другие стуктуры с именами идентификаторов, сохранение контекста генераторов)

Когда в execution стеке появляется ссылка на какую-то job, которая должна быть выполнена, благодаря ссылке на realm рантайм может восстановить всю среду вокруг это job для корректного ее выполнения

Изначально realm содержит структуры для создания глобального объекта (дефолтные значения) или ссылка на уже созданный глобальный объект

realm - корневая сущность, содержащая ссылки на глобальный объект, на выполняемый job, realm может быть один на несколько job
