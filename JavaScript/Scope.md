Javascript Scope

Основная идея - JS запускается двумя фазами
- Парсинг (компиляция)
- Исполнение

Скоуп переменных формируется во время фазы парсинга. В процессе мы проходимся по коду и формируем отдельный скоуп для блоков. Если переменная уже существует с скоупе, ее декларация пропускается, если нет - мы закидываем переменную в скоуп

Есть скоуп блока и скоуп функции

let/const определяют переменную в скоупе блока
var - в скоупе функции. Автоматически инициализирует переменную как undefined в начале скоупа

Выделение памяти происходит только при исполнении, при парсинге мы чисто раскидываем переменные по скоупам, чтобы уже дальше пр выполнении движок по ним проходил и присваивал значения

При этом каждая переменная маркируется, к какому скоупу она принадлежит, так что, когда движок до нее доходит, ему не нужно прыгать по всем скоупам. Исключение - когда у нескольких файлов пошаренный глобальный скоуп

Shadowing - декларация той же переменной во внутреннем скоупе (мы не можем получить доступ к внешней переменной)

Hoisting

Hoisting - возможность обратиться к переменной до того, как мы ее объявили в коде. Также распространятся на function declaration
Работает только в пределах функционального скоупа, не блочного


При этом, если для переменной через var мы будем видеть только то, что она задекларирована, но без значения, у function declaration есть особенность - function hoisting. Когда мы декларируем имя функции, мы автоматом привязываем его к ссылке на функцию, поэтому она можем быть вызвана в любом месте внутри скоупа

У let и const также наблюдается hoisting, но только внутри блочного скоупа

Re-declaration

Если мы объявили переменную с var, повторное ее объявление с var скипается

Если объявили с let, повторно объявлять ее в том же скоупе уже нельзя (будет SyntaxError)

У параметров также есть их скоуп, если мы обхявляем дефолтные значения. Они создаются в отдельном скоупе, и, если там есть замыкание, она замыкается именно на переменную из того скоупа

function whatsTheDealHere(id, defaultID = () => id) {
  let id = 5;
  console.log( defaultID() );
}

whatsTheDealHere(3);
// 3



При этом у let и const присутствуют накладные расходы на вызов, так что var получается производительнее на фазе анализа
