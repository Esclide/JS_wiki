This

Отличие от лексического скоупа

Лексический скоуп представляет статический контекст для функции. Значения лексического контекста определены в момент написания функции

This, напротив, представляет собой динамический контекст. Определение значения this происходит не во время написания кода, а во время рантайма (в отличие от лексического контекста). Т.е. нельзя по функции определить, с каким значением this ей придется оперировать. Необходимо смотреть, как эта функция вызывается

Определение this

1. Функция была вызвана с new keyword? Создаем новый this
2. Функция была вызвана с call, apply, который явно передает this?
3. Функция была вызвана с ссылкой на место вызова (point.init()), неявно передавая this?
4. Ставим контекст по умолчанию

В strict mode контекст по умолчанию undefined, в нестрогом - globalThis

Если не передавать контекст функции явно при вызове (например, object.func(), где onject. - явное указание контекста), то передается контекст по умолчаниюПри создании функции через конструктор (new) создается объект с новым контекстом

function b(x, y = 10){
    this.a = 3;
    console.log(this)
}

b() - контекст - undefined, так что ошибкаnew b() - изначально пустой контекст, после выполнения {a: 3}

Функции оперирования с контекстом

function1.call(newThis, arg1, arg2, arg3)
function1.apply(newThis, [arg1, arg2, arg3])

Разница в том, как мы передаем аргументы. В обоих случаях вызывается исходная функция, в которую передается контекст, указанный первым параметром

newFunction = function1.bind(newThis)

Тут мы создаем новую функцию, где прибиваем this к объекту, который мы передаем

По факту получается

function bind(fn, context) {
  return function bound(…args) {
    return fn.apply(context, args)
  }
}

(1, functionWithThis)() - в таком случае мы заменяем контекст functionWithThis на контекст по умолчанию



class some2 {
    x
    y = 10

    constructor(x1, y1) {
        console.log('constructor')
        console.dir(this)
        this.x = x1;
        this.y = y1;
    }

    log1() {
        console.dir('log1')
        console.dir(this)
    }

    log2 = () => {
        console.dir('log2')
        console.dir(this)
    }
}

при вызове через инстанс класса у log1 и log2 this одинаковые
