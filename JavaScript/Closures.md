Замыкания и контекст

Замыкания (Closures)

Каждая функция остается соединенной с переменными окружающей ее функции, даже если она покидает скоуп, в котором была создана

function createIncrementor(start) {
    return function () {  // (1)
        start++;
        return start;
    }
}

Тут вторая функция покидает контекст, в котором была создана, но в дальнейшем имеет доступ к текущему значению переменной start.

Т.е. Замыкание - это функция плюс окружающий ее контекст

При этом значение всегда привязывается к внешней переменной, если ее меняем, то оно меняется и в функции

var result = [];
for (var i=0; i < 5; i++) {
    result.push(function () { return i });  // (1)
}
console.log(result[1]()); // 5 (not 1)
console.log(result[3]()); // 5 (not 3)

Условия замыкания:

- Должна быть функция
- Должна ссылаться на хотя бы одну переменную из внешнего скоупа
- Должна быть вызвана в спокупе, отличном от скоупа переменной
- Зависит не от скоупа, а от конкретных переменных (но не всегда)

Внешний скоуп не всегда должен быть от функции. Главное - чтобы была функция во внешнем скоупе

Плюсы

+ Замыкание может повысить эффективность кода позволяя запоминать вычисленную информацию вместо того, чтобы вычислять ее каждый вызов
+ Обеспечивает инкапсуляцию, позволяя получать доступ к переменным изнутри функции, но не снаружи

Минусы

- Старые движки хреново работают с замыканиями и могут не оптимизировать, подтягивать в замыкание лишние переменные
- С eval вообще все ломается и в замыкание тащится весь скоуп

Контекст

Если мы экстрактим метод из объекта, то он теряет привязку к своему контексту. Вернуть ее мы можем с помощью функции bind

> var func = jane.describe;
> func()
TypeError: Cannot read property 'name' of undefined

> var func2 = jane.describe.bind(jane);
> func2()
'Person named Jane'

Каждая функция имеет свой уникальный this, но мы можем положить его в переменную и иметь доступ из вложенных блоков

